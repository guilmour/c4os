GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....

Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....
Iniciando ....

GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
GRUB_DEFAULT=0
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=
# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_HIDDEN_TIMEOUT=0
GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"
GRUB_CMDLINE_LINUX=

.struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 
struct group_info init_groups = { .usage = ATOMIC_INIT(2) }; 
 
struct group_info *groups_alloc(int gidsetsize){ 
    struct group_info *group_info; 
    int nblocks; 
    int i; 
 
 
    nblocks = (gidsetsize + NGROUPS_PER_BLOCK - 1) / NGROUPS_PER_BLOCK; 
    /* Make sure we always allocate at least one indirect block pointer */ 
    nblocks = nblocks ? : 1; 
    group_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), GFP_USER); 
    if (!group_info) 
        return NULL; 
 
    group_info->ngroups = gidsetsize; 
    group_info->nblocks = nblocks; 
    atomic_set(&group_info->usage, 1); 
 
    if (gidsetsize <= NGROUPS_SMALL) 
        group_info->blocks[0] = group_info->small_block; 
    else { 
        for (i = 0; i < nblocks; i++) { 
            gid_t *b; 
            b = (void *)__get_free_page(GFP_USER); 
            if (!b) 

.
.
.
.
.
.
.
.
.
.
